# 가상 메모리 (Virtual Memory)

운영체제(OS)가 물리 메모리(RAM)를 더 효율적·안전하게 관리하도록 도와주는 핵심 개념입니다. 백엔드 개발자로서도 메모리 관리 원리를 이해하면, 애플리케이션 성능 최적화나 장애 대응 시 큰 도움이 됩니다.

---

## 1. 정의
- **프로세스마다 독립된 메모리 공간을 주는 기법**  
  각 프로세스(애플리케이션)가 자신만의 메모리 공간을 갖고 있다고 “착각”하게 만듭니다.
- 실제로는 **가상 주소 → 물리 주소** 매핑 테이블을 통해 투명하게 변환합니다.

---

## 2. 왜 필요한가?
1. **격리(Isolation)**  
   프로세스끼리 메모리를 침범하지 못하도록 보호  
2. **효율적 메모리 사용**  
   실제 메모리보다 큰 공간처럼 동작하게 하고, 안 쓰는 페이지는 디스크로 내보냄  
3. **프로그래밍 편의성**  
   개발자는 복잡한 주소 계산 없이 메모리를 사용할 수 있음

---

## 3. 동작 원리

### 3.1 페이지(Page) 단위 관리
- 메모리를 고정 크기 블록(예: 4KB) 단위로 관리  
- 이 블록을 **가상 페이지(Virtual Page)** 와 **물리 프레임(Frame)** 으로 나눔  

### 3.2 페이지 테이블(Page Table)
- **가상 주소**를 **물리 주소**로 매핑하는 사전 역할  
- 각 프로세스별로 독립적인 페이지 테이블 보유  
- CPU 내 MMU(Memory Management Unit)가 자동 변환 수행  

### 3.3 TLB(Translation Lookaside Buffer)
- 자주 참조되는 페이지 테이블 엔트리를 **캐시**  
- 매핑 속도를 대폭 향상

---

## 4. 페이지 폴트(Page Fault)
프로세스가 접근하려는 가상 페이지가 물리 메모리에 없을 때 발생하는 예외입니다.

1. CPU → MMU: 가상 주소 요청  
2. MMU: TLB 미스 → 페이지 테이블 조회  
3. 페이지 테이블 미스 → 페이지 폴트 인터럽트  
4. OS 커널: 디스크(스왑 영역)에서 해당 페이지 로드  
5. 페이지 테이블 업데이트 → 명령 재시도  

---

## 5. 페이지 교체 알고리즘
물리 메모리가 가득 찼을 때, 어떤 페이지를 내보낼지 결정하는 방법입니다.

- **LRU (Least Recently Used)**: 가장 오랫동안 사용되지 않은 페이지  
- **FIFO (First In, First Out)**: 먼저 들어온 순서대로  
- **OPT (Optimal)**: 앞으로 가장 오랫동안 사용되지 않을 페이지 (이론적)  

---

## 6. 장단점

| 장점                                       | 단점                                      |
| ------------------------------------------ | ----------------------------------------- |
| 1. 프로세스 격리로 안정성↑                 | 1. 페이지 폴트 시 디스크 I/O 오버헤드 발생 |
| 2. 물리 메모리 초과 사용 가능               | 2. 내부 단편화(남는 공간) 발생            |
| 3. 프로그래밍 복잡도 ↓                     | 3. 과도한 스왑으로 성능 저하 가능          |

---

## 7. 백엔드 개발자에게 중요한 이유
- **메모리 누수·오버플로우 디버깅**  
  JVM 힙·스택 구조를 이해해 OOM(OutOfMemoryError) 원인 분석  
- **성능 최적화**  
  페이지 폴트 비용을 줄이는 데이터 구조·알고리즘 설계  
- **시스템 아키텍처 설계**  
  TLB 캐시 개념을 분산 캐시(Redis, CDN) 설계에 응용

---

> ✨ 가상 메모리 개념을 익힌 후, 다음에는 **JVM 힙 구조**와의 연계를 살펴보며 실제 자바 애플리케이션 튜닝 사례를 다뤄보겠습니다!

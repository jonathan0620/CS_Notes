## 1. 기본 개념

### 1.1 가상 메모리란?
- **프로세스마다 독립된 메모리 공간**을 제공하는 기법입니다.  
- OS가 ‘가상 주소 → 물리 주소’ 매핑 테이블을 관리해, 프로세스는 자신만의 연속적인 메모리 공간을 갖는 것처럼 동작합니다.

### 1.2 페이지(Page) vs 프레임(Frame)
- **가상 페이지(Virtual Page)**  
  프로세스가 보는 4KB(예시) 단위의 메모리 블록  
- **물리 프레임(Physical Frame)**  
  실제 RAM에서 관리되는 동일 크기의 블록  
- 페이지 하나가 프레임 하나에 매핑되어 메모리 접근이 이루어집니다.

### 1.3 페이지 테이블(Page Table)
- **역할**  
  가상 주소(페이지 번호 + 오프셋) → 물리 주소(프레임 번호 + 오프셋) 변환  
- **구조**  
  - 프로세스마다 독립적인 1차원 배열(또는 다단계 트리)  
  - 각 엔트리(Entry)에 ‘프레임 번호 + 상태 비트(유효/스왑 여부 등)’ 저장

### 1.4 TLB(Translation Lookaside Buffer)
- **역할**  
  자주 참조되는 페이지 테이블 엔트리를 캐시에 저장  
- **해결하는 문제**  
  페이지 테이블(메모리) 조회 비용을 줄여 **주소 변환 속도**를 대폭 향상

---

## 2. 동작 원리 & 예외 상황

### 2.1 페이지 폴트(Page Fault) 발생 과정
1. CPU → MMU: 가상 주소 접근 요청  
2. MMU: TLB 미스 → 페이지 테이블 조회  
3. 페이지 테이블 엔트리 “유효하지 않음” → 페이지 폴트 인터럽트  
4. OS 커널: 디스크(스왑 영역)에서 해당 페이지 Read  
5. 페이지 테이블 업데이트 → CPU 명령 재시도

### 2.2 스왑(Swap) vs 페이징(Paging)
- **페이징**: 가상 페이지 단위로 메모리 ↔ 디스크 블록 교체  
- **스왑**: 프로세스 전체(또는 큰 단위)를 디스크로 옮기는 방식

### 2.3 단편화(Fragmentation)
- **내부 단편화**: 페이지보다 작은 데이터가 남아버린 공간  
- **외부 단편화**: 가변 크기 할당 후 남은 작은 조각들이 흩어져 있는 상태

### 2.4 페이지 교체 알고리즘 예시
- **LRU(Least Recently Used)**: 가장 오랫동안 참조되지 않은 페이지 교체  
- **FIFO(First In, First Out)**: 먼저 들어온 순서대로 교체  
- **OPT(Optimal)**: 앞으로 가장 오랫동안 사용되지 않을 페이지 (이론적)

---

## 3. JVM & 자바 연계

### 3.1 JVM에서의 가상 메모리 활용
- **힙(Heap)**, **메타스페이스(Metaspace)** 등 주요 영역이 모두 가상 주소 공간 위에 할당  
- OS의 페이징·스왑 기능 덕분에 JVM은 “실제 RAM 용량 이상”으로 힙을 설정할 수 있음

### 3.2 OutOfMemoryError와 가상 메모리
- **가상 메모리 한계**: 설정한 힙 사이즈를 초과하면 더 이상 페이지를 할당 못해 OOM 발생  
- **스왑 과다**: 디스크 I/O가 급증해 GC 지연 → 결국 메모리 부족

### 3.3 힙 vs 스택 매핑
- **스택(Stack)**: 각 쓰레드별 고정 크기 가상 페이지로 할당  
- **힙(Heap)**: 동적 용량으로 필요한 만큼 가상 페이지를 요청/반납하며 관리  

---
